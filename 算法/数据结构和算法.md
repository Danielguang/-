## 栈

1. 后进后出
2. 常用操作 push, pop, stack[stack.length -1];

### 场景

1. 判断 []{}是否正确
2. 二进制
3. 方法推栈



## 队列

1. 先进先出

#### 场景

1. 食堂排队打饭
2. Js 异步中的任务队列
3. 计算最近请求次数

### 链表

数组，增加和删除往往需要移动元素，但链表增删不需要移动元素，改变next 指向就可以



### 集合

- 无序且唯一

  ``` javascript
  const arr = [...new set(arr)];
  ```

### 字典

- 与集合类似，但是以键值队存储

### 树

- 一种分层数据的抽象模型
- 前端的DOM树，级联选择，树形控件
- 深度优先遍历： 尽可能深的搜索树的分支
  - 访问根节点
  - 对根节点的children挨个深度优先遍历
- 广度优先遍历： 先访问离根节点最近的节点
  - 新建一个队列，把根节点入队
  - 把队头出队并访问
  - 把队头的children挨个入队
  - 重复第二，第三，直到队列为空

#### 二叉树

- 树中每个节点最多只能有两个子节点
- 在JS中通常会用Object 来模拟二叉树
- 先序遍历
  - 访问根节点
  - 对根节点的左子树进行先序遍历
  - 对根节点的右子树进行先序遍历
- 中序遍历
  - 对根节点的左子树进行中序遍历
  - 访问根节点
  - 对根节点的右子树进行中序遍历
- 后序遍历
  - 对根节点的左子树进行后序遍历
  - 对根节点的右子树进行后序遍历
  - 访问根节点



### 图

- 图是网络结构的抽象模型，是一组由边连接的节点
- 图可以表示任何的二元关系，比如道路，航班
- 深度优先遍历和广度优先遍历
  - 深度优先遍历
    - 访问根节点

    - 对根节点的<b>没访问的相邻节点</b>挨个进行优先遍历

      ```javascript
      const graph = require('./graph');
      const visited = new Set();
      const dfs = (n)=>{
        console.log(n);
        visited.add(n);
        graph[n].forEach(c => {
          if(!visited.has(c)){
            dfs(c);
          }
        });
      }
      ```

      

  - 广度优先遍历算法
    - 新建一个队列
    - 把队头出队并访问
    - 把队头<b>没访问的相邻节点</b>入队
    - 重复二三，直到队列为空
    
    ``` javascript
    const graph = require('./graph');
    const visit = new Set();
    
    
    const bfs = (root)=>{
      const q = [root];
      visit.add(n);
      while(q.length){
        const n = q.shift();
        console.log(n);
        graph[n].forEach(c =>{
          if(!visit.has(c)){
            q.push(c);
            visit.add(c);
          }
        })
      }
    }
    ```
    
    

### 堆

- 堆是一种完全二叉树

![image-20201010152658524](/Users/zhaoguangyu/Library/Application Support/typora-user-images/image-20201010152658524.png)

- 最大堆（所有节点都大于最大），最小堆（所有节点都小于子节点）
- JS 中通常用数组表示堆
- 左侧子节点的位置 2 * index +1
- 右侧子节点的位置 2 * index +2
- 父节点位置（index -1）/2;
- 使用场景 找出第K个最大元素



### JS 中的排序

1. JS中的排序： 数组的sort方法
2. JS中的搜索： 数组的index

### 排序

#### 冒泡排序

1. 比较所有相邻元素，如果第一个比第二个大，则交换

2. 一轮下来，可以保证最后一个数是最大的

3. 执行 n - 1 轮，就可以完成排序

   时间复杂度

   1. 两个嵌套循环
   2. 时间复杂度 0（n ^2）



归并排序

1. 分： 把数组劈成两半，再递归的对子数组进行 ‘分’操作，直到分成一个个单独的树
2. 合：把两个数合并成有序数组，在对有序数组进行合并，直到全部子数组合并成一个完整数组
   1. 新建一个空数组 res, 用于存放最终排序后的数组
   2. 比较两个有序数组的头部，较小者出队并推入res 中
   3. 如果两个数组还有值，就重复第二步

快速排序

1. 分区： 从数组中任意选择一个基准，所有比基准小的元素放在基准前面，比基准大的元素放在基准后面
2. 递归： 递归地对基准前后的子数组进行分区



### 搜索算法

#### 二分搜索的思路

1. 从数组的中间元素开始，如果中间元素正好是目标值，则搜索结束
2. 如果目标值大于或小于中间元素，则在大于或小于中间元素的那一半数组中搜索



### 动态规划

- 分解，将一个问题分解为相互重叠的子问题
- 求解，通过反复求解子问题，从而解决原来的问题



### 分而治之

1. 分而治之是算法设计中的一种算法
2. 他将一个问题<span style="color:red">分</span>成多个和原问题相似的小问题，递归<span style="color:red">解</span>决小问题，再将结果<span style="color:red">合</span>并以解决原来的问题

递归：

1. 明白函数的定义
2. 找到结束条件
3. 第三要素：找出函数的等价关系式